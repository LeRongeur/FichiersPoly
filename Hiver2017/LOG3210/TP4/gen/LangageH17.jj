/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. LangageH17.jj */
/*@egen*/options {
	JAVA_UNICODE_ESCAPE=true;
	STATIC=false;					                                            
	           						                            
	             					                                    
	                      
}

//
// PARSER DEFINITION
//

PARSER_BEGIN(Parser)

class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
	public static void main(String args[])
	{
		Parser c = new Parser(new java.io.DataInputStream(System.in));
		try {
			ASTProgram n = c.Program();
			ParserVisitor v = new CodeGenVisitor();
			n.jjtAccept(v,null);
			//n.dump(" ");
		} catch (Exception e) {
			System.out.println("Erreur: " + '\n' + e);
			System.exit(-1);
		}
	}
}

PARSER_END(Parser)

//
// LEXICAL ANALYSIS
//

// White space

SKIP :
{
	< ( " " | "\t" | "\n" | "\r" )+	>
}

// Comments

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}




// Keywords
TOKEN :
{
	< IF: "if"	> |
	< ELSE: "else" > |
	< WHILE: "while" > | 
	< TYPE: < STRING > | < INT > | < FLOAT > | < BOOL > > |
	< #STRING: "string"> |
	< #INT: "int"> |
	< #FLOAT: "float" > |
	< #BOOL: "bool"> |
	< PRINT: "print" > |
	< INPUT: "input" >
	// A COMPLETER
}

// Operators
TOKEN :
{
	<ASSIGN: < EQUAL > | < PLUSEQUAL > | < MINUSEQUAL > | < POWEQUAL > | < DIVEQUAL > | < FOISEQUAL > > |
	<COMPARE: < LESS > | < LESSEQUAL > | < GREAT > | <GREATEQUAL > | < DIFF > | < EQUALEQUAL > > |
	
	< #LESS: "<" > | 
	< #LESSEQUAL: "<=" > | 
	< #GREAT: ">" > | 
	< #GREATEQUAL: ">=" > | 
	< #DIFF: "!=" > | 
	< #EQUALEQUAL: "==" > |
	
	< PLUS: "+" > |
	< MINUS: "-" > |
	< FOIS: "*" > |
	< DIV: "/" > |
	< POW: "^" > |
	< AND: "&&" > |
	< OR: "||" > |
	< NOT: "not" > |
	
	< #EQUAL: "=" > |
	< #PLUSEQUAL: "+=" > |
	< #MINUSEQUAL: "-=" > |
	< #POWEQUAL: "^=" > |
	< #DIVEQUAL: "/=" > |
	< #FOISEQUAL: "*=" > |
	< LPAREN: "(" > |
	< RPAREN: ")" > |
	< LACC: "{" > |
	< RACC: "}" > |
	< COLON: ":" > |
	< SEMICOLON: ";" > |
	< COMMA: "," >
	// A COMPLETER
}


// Identifiers and numbers
TOKEN :
{
	< IDENTIFIER: <LETTER> ( <LETTER> | <DIGIT> )* > |
	< #LETTER: ["a"-"z","A"-"Z","_"] > |
	< #DIGIT: ["0"-"9"] > |
	< INTEGER: ["1"-"9"] (["0"-"9"])* | "0" > |
	// // Caution! Allows numbers such as "0000.23"
	< REAL: (<INTEGER>)+ "." (["0"-"9"])+ (<EXPONENT>)? |
			  (<INTEGER>)+ <EXPONENT> > |
	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}







//
// SYNTAX ANALYSIS
//

ASTProgram Program() : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(this, JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Program */
        try {
/*@egen*/
	Block() <EOF>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ { return jjtn000;  }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Block() : {/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(this, JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Block */
         try {
/*@egen*/
	 ( Stmt() )*/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

void Stmt() : {/*@bgen(jjtree) Stmt */
  ASTStmt jjtn000 = new ASTStmt(this, JJTSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Stmt */
        try {
/*@egen*/
	
	AssignStmt() ";" |
	WhileStmt() |
	IfStmt()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
	
	
}

void AssignStmt() : {/*@bgen(jjtree) AssignStmt */
                      ASTAssignStmt jjtn000 = new ASTAssignStmt(this, JJTASSIGNSTMT);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token assignOp; }
{/*@bgen(jjtree) AssignStmt */
        try {
/*@egen*/
	(LOOKAHEAD(2) Identifier() assignOp = <ASSIGN>
	{
		jjtn000.addOp(assignOp.image);
	}
	)+ CompExpr()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CompExpr() : {/*@bgen(jjtree) CompExpr */
                    ASTCompExpr jjtn000 = new ASTCompExpr(this, JJTCOMPEXPR);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token compareOp; }
{/*@bgen(jjtree) CompExpr */
        try {
/*@egen*/
	AndOrExpr() ( 
	compareOp = <COMPARE> 
	{
		jjtn000.addOp(compareOp.image);
	}
	AndOrExpr() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AndOrExpr() : {/*@bgen(jjtree) AndOrExpr */
                     ASTAndOrExpr jjtn000 = new ASTAndOrExpr(this, JJTANDOREXPR);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/ Token operator; }
{/*@bgen(jjtree) AndOrExpr */
        try {
/*@egen*/
	NotExpr() ( (operator = "&&" | operator= "||" ) 
	{
		jjtn000.addOp(operator.image);
	}
	 NotExpr() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NotExpr() : {/*@bgen(jjtree) NotExpr */
                   ASTNotExpr jjtn000 = new ASTNotExpr(this, JJTNOTEXPR);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ int compteur = 0; }
{/*@bgen(jjtree) NotExpr */
        try {
/*@egen*/
	("not" { compteur++; })* 
	{
		if(compteur%2 == 1)
		{
			jjtn000.addOp("not");
		}
		else
		{
			jjtn000.addOp("");
		}
	}
	 AddExpr()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AddExpr() : {/*@bgen(jjtree) AddExpr */
                   ASTAddExpr jjtn000 = new ASTAddExpr(this, JJTADDEXPR);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token operator; }
{/*@bgen(jjtree) AddExpr */
        try {
/*@egen*/
	MultExpr() ( (operator = "+"| operator = "-") 
	{
		jjtn000.addOp(operator.image);
	}
	 MultExpr() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MultExpr() : {/*@bgen(jjtree) MultExpr */
                    ASTMultExpr jjtn000 = new ASTMultExpr(this, JJTMULTEXPR);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token operator; }
{/*@bgen(jjtree) MultExpr */
        try {
/*@egen*/
	PowExpr() ( (operator = "*" | operator = "/") 
	{
		jjtn000.addOp(operator.image);
	}
	 PowExpr() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PowExpr() : {/*@bgen(jjtree) PowExpr */
                   ASTPowExpr jjtn000 = new ASTPowExpr(this, JJTPOWEXPR);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token operator; }
{/*@bgen(jjtree) PowExpr */
        try {
/*@egen*/
	NegExpr() ( operator = "^" 
	{
		jjtn000.addOp(operator.image);
	}
	NegExpr() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void NegExpr() : {/*@bgen(jjtree) NegExpr */
                   ASTNegExpr jjtn000 = new ASTNegExpr(this, JJTNEGEXPR);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/ int compteur = 0; }
{/*@bgen(jjtree) NegExpr */
        try {
/*@egen*/
	("-" { compteur++; })* 
	{
		if(compteur%2 == 1)
		{
			jjtn000.addOp("-");
		}
		else
		{
			jjtn000.addOp("");
		}
	}
	 BasicExpr()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void BasicExpr() : {/*@bgen(jjtree) BasicExpr */
  ASTBasicExpr jjtn000 = new ASTBasicExpr(this, JJTBASICEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BasicExpr */
        try {
/*@egen*/
	Identifier()|
	IntValue() | 
	RealValue() | 
	"(" CompExpr() ")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Identifier() : {/*@bgen(jjtree) Identifier */
                      ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) Identifier */
        try {
/*@egen*/
	t = <IDENTIFIER>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {jjtn000.setValue(t.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IntValue() : {/*@bgen(jjtree) IntValue */
                    ASTIntValue jjtn000 = new ASTIntValue(this, JJTINTVALUE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) IntValue */
        try {
/*@egen*/
	t = <INTEGER>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ {jjtn000.setValue(Integer.parseInt(t.image));}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void RealValue() : {/*@bgen(jjtree) RealValue */
                     ASTRealValue jjtn000 = new ASTRealValue(this, JJTREALVALUE);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) RealValue */
        try {
/*@egen*/
	t = <REAL>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.setValue(Double.parseDouble(t.image));}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void WhileStmt() : {/*@bgen(jjtree) WhileStmt */
  ASTWhileStmt jjtn000 = new ASTWhileStmt(this, JJTWHILESTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStmt */
        try {
/*@egen*/
	"while" CompExpr() ":" "{" Block() "}"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IfStmt() : {/*@bgen(jjtree) IfStmt */
  ASTIfStmt jjtn000 = new ASTIfStmt(this, JJTIFSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStmt */
        try {
/*@egen*/
	"if" CompExpr() ":" "{" Block() "}" ["else" "{" Block() "}"]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}