/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. LangageH17.jj */
/*@egen*/options {
	JAVA_UNICODE_ESCAPE=true;
	STATIC=false;					                                            
	           						                            
	             					                                    
	                      
}

//
// PARSER DEFINITION
//

PARSER_BEGIN(LEParser)

class LEParser/*@bgen(jjtree)*/implements LEParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTLEParserState jjtree = new JJTLEParserState();

/*@egen*/
	public static void main(String args[])
	{
		System.out.println("Lecture de l'entree standard...");
		LEParser c = new LEParser(new java.io.DataInputStream(System.in));
		try {
			SimpleNode n = c.Program();
			System.out.println("Fichier analyse avec succes!");
			n.dump(" ");
		} catch (Exception e) {
			System.out.println("Erreur: " + '\n' + e);
			System.exit(-1);
		}
	}
}

PARSER_END(LEParser)

//
// LEXICAL ANALYSIS
//

// White space

SKIP :
{
	< ( " " | "\t" | "\n" | "\r" )+	>
}

// Comments

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}





// Keywords
TOKEN :
{	
	< DECL_TYPES: <BOOL> | <INT> | <FLOAT> | <STRING> > |
	< IF: "if"	> 

	// A COMPLETER

	| < ELSE: "else" > |
	< WHILE: "while" > |
	< #BOOL: "bool" > |
	< #INT: "int" > |
	< #FLOAT: "float" > |
	< #STRING: "string" > 
	
}

// Operators
TOKEN :
{
	< ASSIGN_OPERATORS: <EQUAL> | <PLUS_EQUAL> | <MINUS_EQUAL> | <DIVISION_EQUAL> | <MULTIPLICATION_EQUAL> | <PUISSANCE_EQUAL> > |

	< COMPARISON_OPERATORS: <PLUSPETIT> | <PLUSPETIT_EQUAL> | <PLUSGRAND> | <PLUSGRAND_EQUAL> | <EQUAL_EQUAL> | <NOT_EQUAL> > |


	< PLUS: "+" > |
	< MINUS: "-" > |
	< #EQUAL: "=" > |
	< LPAREN: "(" > |
	< RPAREN: ")" > |
	< SEMICOLON: ";" > |
	< COMMA: "," >

	// A COMPLETER
	| < #PLUS_EQUAL: "+=" > |
	< #MINUS_EQUAL: "-=" > |
	< #DIVISION_EQUAL: "/=" > |
	< #MULTIPLICATION_EQUAL: "*=" > |
	< #PUISSANCE_EQUAL:  "^=" > |

	< #PLUSPETIT: "<" > |
	< #PLUSPETIT_EQUAL: "<=" > |
	< #PLUSGRAND: ">" > |
	< #PLUSGRAND_EQUAL: ">=" > |
	< #EQUAL_EQUAL: "==" > |
	< #NOT_EQUAL: "!=" > |

	< ET: "&&" > |
	< OU: "||" > |

	< NOT: "not" > |

	< MULTIPLICATION: "*" > |
	< DIVISION: "/" > |

	< PUISSANCE: "^" > |	

	< LBRACKET: "{" > |
	< RBRACKET: "}" > |

	<COLON: ":" >
}





// Identifiers and numbers
TOKEN :
{
	< IDENTIFIER: <LETTER> ( <LETTER> | <DIGIT> )* > |
	< #LETTER: ["a"-"z","A"-"Z","_"] > |
	< #DIGIT: ["0"-"9"] > |
	< INTEGER: ["1"-"9"] (["0"-"9"])* | "0" > |
	// // Caution! Allows numbers such as "0000.23"
	< REAL: (<INTEGER>)+ "." (["0"-"9"])+ (<EXPONENT>)? |
			  (<INTEGER>)+ <EXPONENT> > |
	< #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}







//
// SYNTAX ANALYSIS
//

ASTProgram Program() : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(this, JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Program */
        try {
/*@egen*/
	Block() <EOF>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
	// Block() represente un non-terminal.
	// <EOF> represente le terminal indiquant la fin du flot de caracteres.
}

void Block() : {/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(this, JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Block */
         try {
/*@egen*/
	// TODO: Un bloc est compose de 0, 1 ou plusieurs intructions.
	 (Decl() <SEMICOLON>)* (LOOKAHEAD(2) (Stmt() <SEMICOLON> ) | If() | While() | Fct() <SEMICOLON> )*/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
         }
/*@egen*/
}

void Expr() : {/*@bgen(jjtree) Expr */
  ASTExpr jjtn000 = new ASTExpr(this, JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Expr */
        try {
/*@egen*/ 
	(Var() (LOOKAHEAD(1) Arithmetique_operators() Expr())*) | (<LPAREN> Expr() (LOOKAHEAD(1) Arithmetique_operators() Expr())* <RPAREN>) | (LOOKAHEAD(1) Arithmetique_operators() Expr())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Stmt() : {/*@bgen(jjtree) Stmt */
  ASTStmt jjtn000 = new ASTStmt(this, JJTSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Stmt */
        try {
/*@egen*/
	// TODO: Represente une instruction.
	(LOOKAHEAD(4) <IDENTIFIER> <ASSIGN_OPERATORS>)+ (Expr())+/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void While() : {/*@bgen(jjtree) While */
  ASTWhile jjtn000 = new ASTWhile(this, JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) While */
        try {
/*@egen*/
	<WHILE> [<NOT>] Var() ((<COMPARISON_OPERATORS> | Arithmetique_operators())  Var())* <COLON> <LBRACKET> Block() <RBRACKET>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void If() : {/*@bgen(jjtree) If */
  ASTIf jjtn000 = new ASTIf(this, JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) If */
        try {
/*@egen*/
	<IF> [<NOT>] Expr() | (Var() (<COMPARISON_OPERATORS> Var() )*) <COLON> <LBRACKET> Block() <RBRACKET> [<ELSE> <LBRACKET> Block() <RBRACKET>]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Decl() : {/*@bgen(jjtree) Decl */
  ASTDecl jjtn000 = new ASTDecl(this, JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Decl */
        try {
/*@egen*/
	<DECL_TYPES> [Negative_value()] <IDENTIFIER> [LOOKAHEAD(2) <ASSIGN_OPERATORS> (Stmt() | Expr())]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Fct() : {/*@bgen(jjtree) Fct */
  ASTFct jjtn000 = new ASTFct(this, JJTFCT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Fct */
        try {
/*@egen*/
	<IDENTIFIER> <LPAREN> Expr() [<COMMA> Expr()] <RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Var() : {/*@bgen(jjtree) Var */
  ASTVar jjtn000 = new ASTVar(this, JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Var */
        try {
/*@egen*/
	[Negative_value()] (<IDENTIFIER> | <INTEGER> | <REAL>)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 

void Arithmetique_operators() : {/*@bgen(jjtree) Arithmetique_operators */
  ASTArithmetique_operators jjtn000 = new ASTArithmetique_operators(this, JJTARITHMETIQUE_OPERATORS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Arithmetique_operators */
        try {
/*@egen*/
	<PLUS> | <MINUS> | <MULTIPLICATION> | <DIVISION> | <PUISSANCE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Negative_value() : {/*@bgen(jjtree) Negative_value */
  ASTNegative_value jjtn000 = new ASTNegative_value(this, JJTNEGATIVE_VALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Negative_value */
        try {
/*@egen*/
	<MINUS>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

// A COMPLETER
// Suggestion: ecrire les regles de la grammaire
// Rappel: Un non-terminal doit definir une fonction.
//         Un terminal est, par exemple, : <IDENTIFIER>
